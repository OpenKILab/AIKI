from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from aiki.agent.prompts import extract_information_prompt_template, time_inference_prompt_template, memory_selection_prompt_template
from typing import List
import json
from datetime import datetime
from datetime import datetime
from aiki.modal.retrieval_data import RetrievalData
 
class AgentAction(Enum):
    QUERY = 'Query'
    ADD = 'Add'
    REPLACE = 'Replace'
    DELETE = 'Delete'


@dataclass  
class Message:  
    role: str 
    type: str  
    content: str
    summary: str
    action: AgentAction
    metadata: dict




def parse_json(text: str) -> dict:
    # 查找字符串中的 JSON 块
    if "json" in text:  
        start = text.find("```json")
        end = text.find("```", start + 7)
        # 如果找到了 JSON 块
        if start != -1 and end != -1:
            json_string = text[start + 7: end]
            print(json_string)
            try:
                # 解析 JSON 字符串
                json_data = json.loads(json_string)
                #valid = check_selector_response(json_data)
                return json_data
            except:
                print(f"error: parse json error!\n")
                print(f"json_string: {json_string}\n\n")
                pass
    elif "```" in text:
        start = text.find("```")
        end = text.find("```", start + 3)
        if start != -1 and end != -1:
            json_string = text[start + 3: end]
            
            try:
                # 解析 JSON 字符串
                json_data = json.loads(json_string)
                return json_data
            except:
                print(f"error: parse json error!\n")
                print(f"json_string: {json_string}\n\n")
                pass
    else:
        start =  text.find("{")
        end = text.find("}", start + 1)
        if start != -1:
            json_string = text[start: end + 1]
            try:
                # 解析 JSON 字符串
                json_data = json.loads(json_string)
                return json_data
            except:
                print(f"error: parse json error!\n")
                print(f"json_string: {json_string}\n\n")
                pass
    return {}

class BaseAgent(ABC):
    @abstractmethod
    def talk(self,message):
        pass

class InfoExtractAgent(BaseAgent):
    def __init__(self, config:dict, extract_model:callable):
        self.extract_model = extract_model
        self.name = 'InfoExtractAgent'
        ...

    def extract_information(self, context:str) -> str:
        ...
        prompt = extract_information_prompt_template.format(user_input=context)
        information = self.extract_model(prompt)
        return information

    def get_time(self, vague_time:str) -> tuple:
        current_time = datetime.now()
        format_string = "%Y-%m-%d %H:%M:%S"
        current_time_str = current_time.strftime(format_string)
        prompt = time_inference_prompt_template.format(vague_time_description=vague_time,current_precise_time=current_time_str)
        time_answer = self.extract_model(prompt)
        return time_answer
    
    def str_to_timestamp(self, time_str:str) -> float:
        format_str = "%Y-%m-%d %H:%M:%S"
        dt_object = datetime.strptime(time_str, format_str)
        timestamp = dt_object.timestamp()
        return timestamp



    def talk(self, message:Message) -> Message:
        context = ""
        if message.type == 'text':
            context = message.content
       
        extracted_information = self.extract_information(context)
        informatioin_dict = parse_json(extracted_information)
        target_memory = informatioin_dict['User Memory']
        vague_time = target_memory[1]
        time_answer = self.get_time(vague_time)
        time_dict = parse_json(time_answer)
        query = target_memory[0] + target_memory[2]
        time_dict['start_time'] = self.str_to_timestamp(time_dict['start_time'])
        time_dict['end_time'] = self.str_to_timestamp(time_dict['end_time'])
        message.metadata = time_dict
        message.summary = query 
        message.action = informatioin_dict['User Intent'] 

        return message




""" class MemoryEditAgent(BaseAgent):
    def __init__(self, config:dict, memo_database:str, process_model:callable):
        self.memo_database = memo_database 
        self.process_model = process_model
        self.name = 'MemoryEditAgent'
        self.memoryfunction = {AgentAction.ADD:self.add, AgentAction.QUERY:self.search, AgentAction.DELETE:self.delete, AgentAction.REPLACE:self.replace}
        ...

    def search(self, Message) -> RetrievalData:
        # return a list of ids
        ...
    
    def add(self, Message) -> bool:
        ...

    def delete(self, Message) -> bool:
        ...
    
    def replace(self, Message) -> bool:
        # merge & replace
        ... 
    

    def load_function(self, process_function:str) -> bool:
        # Parses the function call generated by LLM and calls the corresponding memory operation function.
        try: 
            #fake pass
            func, data_list, id = process_function.split('--')
            if func == 'add':
                return self.add(data_list[0])
            elif func == 'delete':
                return self.delete(id)
            elif func == 'replace':
                return self.edit(self, id, data_list[0])
            elif func == 'merge':
                prompt = merge_memory_prompt_template.format(old_memory=data_list[0],new_memory=data_list[1])
                merged_memory = self.process_model(prompt)
                return self.edit(self, id, merged_memory)
            else:
                return False

        except:
            return False

    def process_memory(self, temp_memory:str, related_memory:str, context:str) -> str:
        ...
        prompt = process_memory_prompt_template.format(temp_memory=temp_memory, related_memory=related_memory, context=context)
        function_call = self.process_model(prompt)
        return function_call
        


    def talk(self, Message) -> Message:
        action = Message.action
        if action == AgentAction.ADD:

        related_memorys = self.search(self, Message)
        related_memory = ""
        for rel_id in range(len(related_memory_ids)):
            memory_part = self.read(rel_id)
            related_memory += f"##Memory_id: {str(rel_id)}\nMemory_content: {memory_part}\n\n"
        process_function = self.process_memory(temp_memory=temp_memory, related_memory=related_memory, context=history)
        while not self.load_function(process_function):
            process_function = self.process_memory(temp_memory=temp_memory, related_memory=related_memory)
        return process_function

    ...
 """
    


    